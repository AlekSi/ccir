// Copyright 2017 The CCIR Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/scanner"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/cznic/cc"
	"github.com/cznic/ccir"
	"github.com/cznic/internal/buffer"
	"github.com/cznic/xc"
)

const (
	morePredefined = `
`
)

var (
	dict        = xc.Dict
	include     []string
	oDebug      = flag.String("debug", "", "")
	oPos        = flag.Bool("pos", false, "")
	oPredefined = flag.Bool("predefined", false, "")
	predefined  string
	sysInclude  []string
)

func errStr(err error) string {
	switch x := err.(type) {
	case scanner.ErrorList:
		if len(x) != 1 {
			x.RemoveMultiples()
		}
		var b bytes.Buffer
		for i, v := range x {
			if i != 0 {
				b.WriteByte('\n')
			}
			b.WriteString(v.Error())
			if i == 9 {
				fmt.Fprintf(&b, "\n\t... and %v more errors", len(x)-10)
				break
			}
		}
		return b.String()
	default:
		return err.Error()
	}
}

func position(n cc.Node) token.Position { return xc.FileSet.Position(n.Pos()) }

func emit(nm string, src string, b []byte) {
	f, err := os.Create(fmt.Sprintf("%s_%s_%s.h", nm, runtime.GOOS, runtime.GOARCH))
	if err != nil {
		log.Fatal(err)
	}

	if _, err := fmt.Fprintf(f, `// Code generated by running "go generate". DO NOT EDIT.

// +build ignore

// source: %s

`, src); err != nil {
		log.Fatal(err)
	}

	b = bytes.TrimSpace(b)
	if _, err := f.Write(b); err != nil {
		log.Fatal(err)
	}
	if _, err := f.WriteString("\n"); err != nil {
		log.Fatal(err)
	}
}

func macro(ast *cc.TranslationUnit, m *cc.Macro) string {
	s := ""
	if m.IsFnLike {
		var a [][]byte
		for _, m := range m.Args {
			a = append(a, dict.S(m))
		}
		s = fmt.Sprintf("(%s)", bytes.Join(a, []byte(", ")))
	}

	repl := m.ReplacementToks()
	if len(repl) > 0 {
		nm := -1
		switch tok := repl[0]; {
		case tok.Rune == cc.IDENTIFIER:
			nm = tok.Val
		case tok.Rune == cc.IDENTIFIER_LPAREN:
			log.Fatal("TODO")
		}
		if nm > 0 {
			if _, ok := ast.Declarations.Identifiers[nm]; ok {
				m.Value = nil
			}
		}
	}
	switch {
	case len(repl) != 0 && m.Value != nil && repl[0].Rune != cc.IDENTIFIER:
		switch m.Type.Kind() {
		case cc.Int, cc.Float, cc.Ptr:
			s = fmt.Sprintf("%s %v", s, m.Value)
		case cc.UInt:
			s = fmt.Sprintf("%s %vu", s, m.Value)
		case cc.Long, cc.LongDouble:
			s = fmt.Sprintf("%s %vl", s, m.Value)
		case cc.ULong:
			s = fmt.Sprintf("%s %vul", s, m.Value)
		case cc.LongLong:
			s = fmt.Sprintf("%s %vll", s, m.Value)
		case cc.ULongLong:
			s = fmt.Sprintf("%s %vull", s, m.Value)
		default:
			log.Fatalf("%s: %v", m.DefTok.Position(), m.Type.Kind())
		}
	default:
		var a []string
		for _, v := range repl {
			a = append(a, cc.TokSrc(v))
		}
		s = fmt.Sprintf("%s %v", s, strings.Join(a, " "))
	}
	return fmt.Sprintf("#define %s%s", dict.S(m.DefTok.Val), s)
}

func structOrUnion(b *buffer.Bytes, n *cc.StructOrUnion) {
	switch n.Case {
	case 0: // "struct"
		b.WriteString("struct ")
	case 1: // "union"   // Case 1
		b.WriteString("union ")
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func identifierOpt(b *buffer.Bytes, n *cc.IdentifierOpt) {
	if n != nil {
		fmt.Fprintf(b, "%s ", dict.S(n.Token.Val))
	}
}

func specifierQualifierListOpt(b *buffer.Bytes, n *cc.SpecifierQualifierListOpt) {
	if n != nil {
		specifierQualifierList(b, n.SpecifierQualifierList)
	}
}

func specifierQualifierList(b *buffer.Bytes, n *cc.SpecifierQualifierList) {
	switch n.Case {
	case 0: // TypeSpecifier SpecifierQualifierListOpt
		typeSpecifier(b, n.TypeSpecifier)
		specifierQualifierListOpt(b, n.SpecifierQualifierListOpt)
	case 1: // TypeQualifier SpecifierQualifierListOpt  // Case 1
		typeQualifier(b, n.TypeQualifier)
		specifierQualifierListOpt(b, n.SpecifierQualifierListOpt)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func typeQualifierList(b *buffer.Bytes, n *cc.TypeQualifierList) {
	switch n.Case {
	case 0: // TypeQualifier
		typeQualifier(b, n.TypeQualifier)
	case 1: // TypeQualifierList TypeQualifier  // Case 1
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func typeQualifierListOpt(b *buffer.Bytes, n *cc.TypeQualifierListOpt) {
	if n != nil {
		typeQualifierList(b, n.TypeQualifierList)
	}
}

func pointer(b *buffer.Bytes, n *cc.Pointer) {
	switch n.Case {
	case 0: // '*' TypeQualifierListOpt
		b.WriteByte('*')
		typeQualifierListOpt(b, n.TypeQualifierListOpt)
	case 1: // '*' TypeQualifierListOpt Pointer  // Case 1
		b.WriteByte('*')
		typeQualifierListOpt(b, n.TypeQualifierListOpt)
		pointer(b, n.Pointer)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func pointerOpt(b *buffer.Bytes, n *cc.PointerOpt) {
	if n != nil {
		pointer(b, n.Pointer)
	}
}

func abstractDeclarator(b *buffer.Bytes, n *cc.AbstractDeclarator) {
	switch n.Case {
	case 0: // Pointer
		pointer(b, n.Pointer)
	case 1: // PointerOpt DirectAbstractDeclarator  // Case 1
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func abstractDeclaratorOpt(b *buffer.Bytes, n *cc.AbstractDeclaratorOpt) {
	if n != nil {
		abstractDeclarator(b, n.AbstractDeclarator)
	}
}

func parameterDeclaration(b *buffer.Bytes, n *cc.ParameterDeclaration) {
	switch n.Case {
	case 0: // DeclarationSpecifiers Declarator
		declarationSpecifiers(b, n.DeclarationSpecifiers)
		declarator(b, n.Declarator)
	case 1: // DeclarationSpecifiers AbstractDeclaratorOpt  // Case 1
		declarationSpecifiers(b, n.DeclarationSpecifiers)
		abstractDeclaratorOpt(b, n.AbstractDeclaratorOpt)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func parameterList(b *buffer.Bytes, n *cc.ParameterList) {
	for first := true; n != nil; n = n.ParameterList {
		if !first {
			b.WriteByte(',')
		}
		first = false
		parameterDeclaration(b, n.ParameterDeclaration)
	}
}

func parameterTypeList(b *buffer.Bytes, n *cc.ParameterTypeList) {
	switch n.Case {
	case 0: // ParameterList
		parameterList(b, n.ParameterList)
	case 1: // ParameterList ',' "..."  // Case 1
		parameterList(b, n.ParameterList)
		b.WriteString(",...")
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func expression(b *buffer.Bytes, n *cc.Expression) {
	if n.Value != nil {
		constantExpression(b, n.Value, n.Type)
		return
	}

	log.Fatalf("%s: internal error: %v", position(n), n.Case)
}

func expressionOpt(b *buffer.Bytes, n *cc.ExpressionOpt) {
	if n != nil {
		expression(b, n.Expression)
	}
}

func directDeclarator(b *buffer.Bytes, n *cc.DirectDeclarator) {
	switch n.Case {
	case 0: // IDENTIFIER
		fmt.Fprintf(b, "%s ", dict.S(n.Token.Val))
	case 1: // '(' Declarator ')'                                                 // Case 1
		b.WriteByte('(')
		declarator(b, n.Declarator)
		b.WriteByte(')')
	case 2: // DirectDeclarator '[' TypeQualifierListOpt ExpressionOpt ']'        // Case 2
		directDeclarator(b, n.DirectDeclarator)
		b.WriteByte('[')
		typeQualifierListOpt(b, n.TypeQualifierListOpt)
		expressionOpt(b, n.ExpressionOpt)
		b.WriteByte(']')
	case 3: // DirectDeclarator '[' "static" TypeQualifierListOpt Expression ']'  // Case 3
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 4: // DirectDeclarator '[' TypeQualifierList "static" Expression ']'     // Case 4
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 5: // DirectDeclarator '[' TypeQualifierListOpt '*' ']'                  // Case 5
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 6: // DirectDeclarator '(' ParameterTypeList ')'                         // Case 6
		directDeclarator(b, n.DirectDeclarator)
		b.WriteByte('(')
		parameterTypeList(b, n.ParameterTypeList)
		b.WriteByte(')')
	case 7: // DirectDeclarator '(' IdentifierListOpt ')'                         // Case 7
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func declarator(b *buffer.Bytes, n *cc.Declarator) {
	pointerOpt(b, n.PointerOpt)
	directDeclarator(b, n.DirectDeclarator)
}

func structDeclarator(b *buffer.Bytes, n *cc.StructDeclarator) {
	switch n.Case {
	case 0: // Declarator
		declarator(b, n.Declarator)
	case 1: // DeclaratorOpt ':' ConstantExpression  // Case 1
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func structDeclaratorList(b *buffer.Bytes, n *cc.StructDeclaratorList) {
	for ; n != nil; n = n.StructDeclaratorList {
		structDeclarator(b, n.StructDeclarator)
	}
}

func structDeclaration(b *buffer.Bytes, n *cc.StructDeclaration) {
	switch n.Case {
	case 0: // SpecifierQualifierList StructDeclaratorList ';'
		specifierQualifierList(b, n.SpecifierQualifierList)
		structDeclaratorList(b, n.StructDeclaratorList)
		b.WriteByte(';')
	case 1: // SpecifierQualifierList ';'                       // Case 1
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 2: // StaticAssertDeclaration                          // Case 2
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func structDeclarationList(b *buffer.Bytes, n *cc.StructDeclarationList) {
	for ; n != nil; n = n.StructDeclarationList {
		structDeclaration(b, n.StructDeclaration)
	}
}

func structOrUnionSpecifier(b *buffer.Bytes, n *cc.StructOrUnionSpecifier) {
	switch n.Case {
	case 0: // StructOrUnion IdentifierOpt '{' StructDeclarationList '}'
		structOrUnion(b, n.StructOrUnion)
		identifierOpt(b, n.IdentifierOpt)
		b.WriteByte('{')
		structDeclarationList(b, n.StructDeclarationList)
		b.WriteByte('}')
	case 1: // StructOrUnion IDENTIFIER                                   // Case 1
		structOrUnion(b, n.StructOrUnion)
		fmt.Fprintf(b, "%s ", dict.S(n.Token.Val))
	case 2: // StructOrUnion IdentifierOpt '{' '}'                        // Case 2
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func enumerationConstant(b *buffer.Bytes, n *cc.EnumerationConstant) {
	fmt.Fprintf(b, "%s ", dict.S(n.Token.Val))
}

func constantExpression(b *buffer.Bytes, v interface{}, t cc.Type) {
	switch t.Kind() {
	case cc.Int:
		fmt.Fprintf(b, "%v ", v)
	case cc.UInt:
		fmt.Fprintf(b, "%vu ", v)
	case cc.Long:
		fmt.Fprintf(b, "%vl ", v)
	case cc.ULong:
		fmt.Fprintf(b, "%vul ", v)
	default:
		log.Fatalf("internal error: %v", t.Kind())
	}
}

func enumerator(b *buffer.Bytes, n *cc.Enumerator) {
	switch n.Case {
	case 0: // EnumerationConstant
		enumerationConstant(b, n.EnumerationConstant)
	case 1: // EnumerationConstant '=' ConstantExpression  // Case 1
		enumerationConstant(b, n.EnumerationConstant)
		b.WriteByte('=')
		constantExpression(b, n.ConstantExpression.Value, n.ConstantExpression.Type)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func enumeratorList(b *buffer.Bytes, n *cc.EnumeratorList) {
	for first := true; n != nil; n = n.EnumeratorList {
		if !first {
			b.WriteByte(',')
		}
		first = false
		enumerator(b, n.Enumerator)
	}
}

func enumSpecifier(b *buffer.Bytes, n *cc.EnumSpecifier) {
	switch n.Case {
	case 0: // "enum" IdentifierOpt '{' EnumeratorList CommaOpt '}'
		b.WriteString("enum ")
		identifierOpt(b, n.IdentifierOpt)
		b.WriteByte('{')
		enumeratorList(b, n.EnumeratorList)
		b.WriteByte('}')
	case 1: // "enum" IDENTIFIER                                     // Case 1
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func typeSpecifier(b *buffer.Bytes, n *cc.TypeSpecifier) {
	switch n.Case {
	case 0: // "void"
		b.WriteString("void ")
	case 1: // "char"                       // Case 1
		b.WriteString("char ")
	case 2: // "short"                      // Case 2
		b.WriteString("short ")
	case 3: // "int"                        // Case 3
		b.WriteString("int ")
	case 4: // "long"                       // Case 4
		b.WriteString("long ")
	case 5: // "float"                      // Case 5
		b.WriteString("float ")
	case 6: // "double"                     // Case 6
		b.WriteString("double ")
	case 7: // "signed"                     // Case 7
		b.WriteString("signed ")
	case 8: // "unsigned"                   // Case 8
		b.WriteString("unsigned ")
	case 9: // "_Bool"                      // Case 9
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 10: // "_Complex"                   // Case 10
		b.WriteString("_Complex ")
	case 11: // StructOrUnionSpecifier       // Case 11
		structOrUnionSpecifier(b, n.StructOrUnionSpecifier)
	case 12: // EnumSpecifier                // Case 12
		enumSpecifier(b, n.EnumSpecifier)
	case 13: // TYPEDEFNAME                  // Case 13
		fmt.Fprintf(b, "%s ", dict.S(n.Token.Val))
	case 14: // "typeof" '(' Expression ')'  // Case 14
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 15: // "typeof" '(' TypeName ')'    // Case 15
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func declarationSpecifiersOpt(b *buffer.Bytes, n *cc.DeclarationSpecifiersOpt) {
	if n != nil {
		declarationSpecifiers(b, n.DeclarationSpecifiers)
	}
}

func storageClassSpecifier(b *buffer.Bytes, n *cc.StorageClassSpecifier) {
	switch n.Case {
	case 0: // "typedef"
		b.WriteString("typedef ")
	case 1: // "extern"    // Case 1
		b.WriteString("extern ")
	case 2: // "static"    // Case 2
		b.WriteString("static ")
	case 3: // "auto"      // Case 3
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 4: // "register"  // Case 4
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func typeQualifier(b *buffer.Bytes, n *cc.TypeQualifier) {
	switch n.Case {
	case 0: // "const"
	case 1: // "restrict"  // Case 1
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 2: // "volatile"  // Case 2
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func declarationSpecifiers(b *buffer.Bytes, n *cc.DeclarationSpecifiers) {
	switch n.Case {
	case 0: // StorageClassSpecifier DeclarationSpecifiersOpt
		storageClassSpecifier(b, n.StorageClassSpecifier)
		declarationSpecifiersOpt(b, n.DeclarationSpecifiersOpt)
	case 1: // TypeSpecifier DeclarationSpecifiersOpt          // Case 1
		typeSpecifier(b, n.TypeSpecifier)
		declarationSpecifiersOpt(b, n.DeclarationSpecifiersOpt)
	case 2: // TypeQualifier DeclarationSpecifiersOpt          // Case 2
		typeQualifier(b, n.TypeQualifier)
		declarationSpecifiersOpt(b, n.DeclarationSpecifiersOpt)
	case 3: // FunctionSpecifier DeclarationSpecifiersOpt      // Case 3
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func initializer(b *buffer.Bytes, n *cc.Initializer) {
	switch n.Case {
	case 0: // Expression
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 1: // '{' InitializerList CommaOpt '}'  // Case 1
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	case 2: // IDENTIFIER ':' Initializer        // Case 2
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}
func initDeclarator(b *buffer.Bytes, n *cc.InitDeclarator) {
	switch n.Case {
	case 0: // Declarator
		declarator(b, n.Declarator)
	case 1: // Declarator '=' Initializer  // Case 1
		declarator(b, n.Declarator)
		b.WriteByte('=')
		initializer(b, n.Initializer)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
}

func initDeclaratorList(b *buffer.Bytes, n *cc.InitDeclaratorList) {
	for ; n != nil; n = n.InitDeclaratorList {
		initDeclarator(b, n.InitDeclarator)
	}
}

func initDeclaratorListOpt(b *buffer.Bytes, n *cc.InitDeclaratorListOpt) {
	if n != nil {
		initDeclaratorList(b, n.InitDeclaratorList)
	}
}

func declaration(n *cc.Declaration) (r scanner.ErrorList) {
	var b buffer.Bytes
	pos := position(n)
	switch n.Case {
	case 0: // DeclarationSpecifiers InitDeclaratorListOpt ';'
		declarationSpecifiers(&b, n.DeclarationSpecifiers)
		initDeclaratorListOpt(&b, n.InitDeclaratorListOpt)
		b.WriteByte(';')
		r.Add(pos, string(b.Bytes()))
	case 1: // StaticAssertDeclaration                          // Case 1
		log.Fatalf("%s: TODO: %v", position(n), n.Case)
	default:
		log.Fatalf("%s: internal error: %v", position(n), n.Case)
	}
	b.Close()
	return r
}

func filter(nm, base, path string) bool {
	if d := *oDebug; d != "" && d == nm {
		return false
	}

	return filepath.Base(path) != base || strings.Contains(filepath.ToSlash(path), "/bits/")
}

func header(nm string) {
	m, err := ccir.Model(runtime.GOARCH)
	if err != nil {
		log.Fatal(err)
	}

	ast, err := cc.Parse(
		fmt.Sprintf(`
#define __os__ %s
#define __arch__ %s
#include <predefined.h>
%s
#include <%s.h>
`, runtime.GOOS, runtime.GOARCH, morePredefined, nm),
		nil,
		m,
		cc.EnableAnonymousStructFields(),
		cc.EnableIncludeNext(),
		cc.IncludePaths(include),
		cc.SysIncludePaths(sysInclude),
	)
	if err != nil {
		log.Fatal(errStr(err))
	}

	var src string
	var out scanner.ErrorList
	base := filepath.Base(nm)
	base = fmt.Sprintf("%s.h", base)
	for _, v := range ast.Macros {
		pos := v.DefTok.Position()
		if filter(nm, base, pos.Filename) {
			continue
		}

		src = pos.Filename
		out.Add(v.DefTok.Position(), macro(ast, v))
	}
	for l := ast; l != nil; l = l.TranslationUnit {
		n := l.ExternalDeclaration
		pos := position(n)
		if filter(nm, base, pos.Filename) {
			continue
		}

		src = pos.Filename
		switch n.Case {
		case 0: // FunctionDefinition
			log.Fatalf("%s: TODO %v", pos, n.Case)
		case 1: // Declaration                  // Case 1
			out = append(out, declaration(n.Declaration)...)
		case 2: // BasicAssemblerStatement ';'  // Case 2
			log.Fatalf("%s: TODO %v", pos, n.Case)
		case 3: // ';'                          // Case 3
			log.Fatalf("%s: TODO %v", pos, n.Case)
		default:
			log.Fatalf("%s: internal error", pos)
		}
	}
	out.Sort()
	var a []string
	for _, v := range out {
		if *oPos || *oDebug == nm {
			v.Msg = fmt.Sprintf("%s // %s", v.Msg, v.Pos)
		}
		a = append(a, v.Msg)
	}
	emit(nm, src, []byte(strings.Join(a, "\n")))
}

func cppMacros() {
	a := strings.Split(predefined, "\n")
	w := 0
	for _, v := range a {
		v = strings.TrimSpace(v)
		l := strings.ToLower(v)
		if v == "" || strings.Contains(l, "gcc") || strings.Contains(l, "gnu") {
			continue
		}
		a[w] = v
		w++
	}
	emit("predefined", "cpp", []byte(strings.Join(a[:w], "\n")))
}

func main() {
	log.SetFlags(log.Lmicroseconds | log.Lshortfile)
	flag.Parse()
	var err error
	if predefined, include, sysInclude, err = cc.HostConfig("-std=c99"); err != nil {
		log.Fatal(err)
	}

	if *oPredefined {
		cppMacros()
		return
	}

	for _, v := range []string{
		"alloca",
		"complex",
		"ctype",
		"dlfcn",
		"errno",
		"fcntl",
		"float",
		"limits",
		"locale",
		"math",
		"memory",
		"pthread",
		"sched",
		"setjmp",
		"signal",
		"stdarg",
		"stdbool",
		"stddef",
		"stdint",
		"stdio",
		"stdlib",
		"string",
		"strings",
		"sys/mman",
		"sys/select",
		"sys/stat",
		"sys/time",
		"sys/types",
		"sys/wait",
		"time",
		"unistd",
		"wchar",
	} {
		header(v)
	}
}
