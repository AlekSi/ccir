// Copyright 2017 The CCIR Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"syscall"
)

func main() {
	log.SetFlags(log.Lshortfile)
	f, err := os.Create("errno.h")
	if err != nil {
		log.Fatal(err)
	}

	w := bytes.NewBuffer(nil)
	fmt.Fprintf(w, `// Code generated by running "go generate". DO NOT EDIT.

#ifndef _ERRNO_H_
#define _ERRNO_H_

int errno = 0;

`)

	for _, v := range []struct {
		s string
		e syscall.Errno
	}{
		{"EACCES", syscall.EACCES},
		{"EAGAIN", syscall.EAGAIN},
		{"EBUSY", syscall.EBUSY},
		{"EINTR", syscall.EINTR},
		{"ENOLCK", syscall.ENOLCK},
		{"EPERM", syscall.EPERM},
		{"ETIMEDOUT", syscall.ETIMEDOUT},
	} {
		fmt.Fprintf(w, "#define %s\t\t%d /* %v */\n", v.s, v.e, v.e)
	}

	fmt.Fprintf(w, `
#endif				/* _ERRNO_H_ */
`)
	if _, err = w.WriteTo(f); err != nil {
		log.Fatal(err)
	}

	if err = f.Close(); err != nil {
		log.Fatal(err)
	}
}
